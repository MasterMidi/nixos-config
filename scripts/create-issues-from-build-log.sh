#!/usr/bin/env bash

# Script to parse build logs and create GitHub issues for errors and warnings
# 
# This script processes JSONL build logs from nix flake check and creates
# GitHub issues for each error (level 0) or warning (level 1) found.
# 
# Usage: create-issues-from-build-log.sh <build-log.jsonl> [--dry-run]
#
# Features:
# - Filters build log for errors (level 0) and warnings (level 1)
# - Avoids duplicate issues in the same run using MD5 hashing
# - Checks for existing open issues with similar titles
# - Labels issues with 'bug' for errors, 'warning' for warnings
# - Adds 'automated' label to all auto-created issues
# - Includes full error/warning message and context in issue body
#
# Options:
# - --dry-run: Print what would be done without creating issues
#
# Requirements:
# - jq: for parsing JSONL build logs
# - gh: GitHub CLI for creating issues
# - GH_TOKEN environment variable: GitHub token with issues:write permission

set -euo pipefail

# Parse arguments
DRY_RUN=false
BUILD_LOG=""

while [[ $# -gt 0 ]]; do
	case $1 in
		--dry-run)
			DRY_RUN=true
			shift
			;;
		*)
			BUILD_LOG="$1"
			shift
			;;
	esac
done

# Check if build log file is provided
if [ -z "$BUILD_LOG" ]; then
	echo "Usage: $0 <build-log.jsonl> [--dry-run]"
	exit 1
fi

if [ ! -f "$BUILD_LOG" ]; then
	echo "Error: Build log file '$BUILD_LOG' not found"
	exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
	echo "Error: jq is not installed"
	exit 1
fi

# Check if gh CLI is installed
if ! command -v gh &> /dev/null; then
	echo "Error: GitHub CLI (gh) is not installed"
	exit 1
fi

# Extract errors and warnings from build log
# level 0 = errors, level 1 = warnings
ISSUES=$(jq -r 'select(.level <= 1 and .action == "msg") | "\(.level)|\(.msg)"' "$BUILD_LOG")

if [ -z "$ISSUES" ]; then
	echo "No errors or warnings found in build log"
	exit 0
fi

# Track created issues to avoid duplicates in the same run
declare -A CREATED_ISSUES

# Process each issue
while IFS='|' read -r level msg; do
	# Determine issue type and label
	if [ "$level" -eq 0 ]; then
		ISSUE_TYPE="error"
		LABEL="bug"
	else
		ISSUE_TYPE="warning"
		LABEL="warning"
	fi

	# Extract a clean title from the message
	# Remove common prefixes and limit length
	TITLE=$(echo "$msg" | sed -e 's/^error: //' -e 's/^warning: //' | head -c 100)
	
	# Create a hash of the message to detect duplicates
	MSG_HASH=$(echo "$msg" | md5sum | cut -d' ' -f1)
	
	# Skip if we already created this issue in this run
	if [ -n "${CREATED_ISSUES[$MSG_HASH]:-}" ]; then
		echo "Skipping duplicate issue: $TITLE"
		continue
	fi
	
	# Check if a similar issue already exists (open issues only)
	EXISTING_ISSUE=$(gh issue list --state open --label "$LABEL" --search "$TITLE" --json number --jq '.[0].number' 2>/dev/null || true)
	
	if [ -n "$EXISTING_ISSUE" ]; then
		echo "Similar issue already exists (#$EXISTING_ISSUE): $TITLE"
		continue
	fi
	
	# Create issue body with build context
	BODY=$(cat <<-EOF
		### Build Log $ISSUE_TYPE
		
		This issue was automatically created from a build log.
		
		**Message:**
		\`\`\`
		$msg
		\`\`\`
		
		**Type:** $ISSUE_TYPE (level $level)
		
		---
		*This issue was automatically generated by the flake-check workflow.*
	EOF
	)
	
	# Create the GitHub issue
	if [ "$DRY_RUN" = true ]; then
		echo "[DRY RUN] Would create issue: $TITLE"
		echo "[DRY RUN] Labels: $LABEL, automated"
		echo "[DRY RUN] Body preview:"
		echo "$BODY" | head -5
		CREATED_ISSUES[$MSG_HASH]="dry-run"
	else
		echo "Creating issue: $TITLE"
		ISSUE_NUMBER=$(gh issue create \
			--title "[$ISSUE_TYPE] $TITLE" \
			--body "$BODY" \
			--label "$LABEL" \
			--label "automated" \
			--json number \
			--jq '.number')
		
		if [ -n "$ISSUE_NUMBER" ]; then
			echo "Created issue #$ISSUE_NUMBER"
			CREATED_ISSUES[$MSG_HASH]="$ISSUE_NUMBER"
		else
			echo "Failed to create issue for: $TITLE"
		fi
	fi
	
done <<< "$ISSUES"

echo "Finished processing build log"
